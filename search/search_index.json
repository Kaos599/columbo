{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Columbo TODO: PyPi Release Badge columbo provides a way to specify a dynamic set of questions to ask a user and get their answers. columbo 's feature set allows a program to: Ask multiple types of questions: Yes or No Multiple choice Open-ended Validate the response provided by the user. Use answers from earlier questions: As part of the text of a question As part of the text of a default value To decide if a question should be skipped Accept answers from the command line in addition to prompting the user. Example User Prompts The primary use of columbo is to define a sequence of interactions that are used to prompt a user to provide answers using a terminal. Below is a sample which shows some ways this can be used. import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions ) print ( answers ) Below shows the output when the user accepts the default values for most of the questions. The user provides a different value for the email and explicitly confirms that they like dogs. Welcome to the Columbo example Press enter to start What is your name? [Patrick]: What email address should be used to contact Patrick? [me@example.com]: patrick@example.com How are you feeling today? 1 - happy 2 - sad 3 - sleepy 4 - confused Enter the number of your choice [1]: Do you like dogs? (Y/n): y {'user': 'Patrick', 'user_email': 'patrick@example.com', 'mood': 'happy', 'likes_dogs': True} Command Line Answers TODO Where to Start? To learn the basics of how to start using columbo , read the Getting Started page. Detailed Documentation To learn more about the various ways columbo can be used, read the Usage Guide page. API Reference To find detailed information about a specific function or class, read the API Reference .","title":"Overview"},{"location":"#columbo","text":"TODO: PyPi Release Badge columbo provides a way to specify a dynamic set of questions to ask a user and get their answers. columbo 's feature set allows a program to: Ask multiple types of questions: Yes or No Multiple choice Open-ended Validate the response provided by the user. Use answers from earlier questions: As part of the text of a question As part of the text of a default value To decide if a question should be skipped Accept answers from the command line in addition to prompting the user.","title":"Columbo"},{"location":"#example","text":"","title":"Example"},{"location":"#user-prompts","text":"The primary use of columbo is to define a sequence of interactions that are used to prompt a user to provide answers using a terminal. Below is a sample which shows some ways this can be used. import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions ) print ( answers ) Below shows the output when the user accepts the default values for most of the questions. The user provides a different value for the email and explicitly confirms that they like dogs. Welcome to the Columbo example Press enter to start What is your name? [Patrick]: What email address should be used to contact Patrick? [me@example.com]: patrick@example.com How are you feeling today? 1 - happy 2 - sad 3 - sleepy 4 - confused Enter the number of your choice [1]: Do you like dogs? (Y/n): y {'user': 'Patrick', 'user_email': 'patrick@example.com', 'mood': 'happy', 'likes_dogs': True}","title":"User Prompts"},{"location":"#command-line-answers","text":"TODO","title":"Command Line Answers"},{"location":"#where-to-start","text":"To learn the basics of how to start using columbo , read the Getting Started page.","title":"Where to Start?"},{"location":"#detailed-documentation","text":"To learn more about the various ways columbo can be used, read the Usage Guide page.","title":"Detailed Documentation"},{"location":"#api-reference","text":"To find detailed information about a specific function or class, read the API Reference .","title":"API Reference"},{"location":"CHANGELOG/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [Unreleased] [0.8.0] - 2020-02-17 Added All Interaction s gained a copy() method to allow for creating slightly altered instances of an existing Interaction . parse_args() and format_cli_help() accept an optional parser_name to be displayed in errors and help text. Changed Stop producing universal wheels. Fixed StaticOrDynamicValue enforces that the result of the callable must be the same type as the static type. Removed DynamicValue is no longer exposed as a type alias. [0.7.0] - 2020-02-10 Added format_cli_help() function to produce CLI help text. Changed Type hints on public API. Be more restrictive when functions should not be making mutations. Be less restrictive when functions don't rely on specific implementations. Fixed CliException inherits from ColumboException . Raise DuplicateQuestionNameException if a list of interactions contains multiple questions with the same name. The same exception is also raised when an existing answers dictionary already contains a name used by a given questions. [0.6.0] - 2020-01-13 Added parse_args() function now accepts an initial dictionary of answers . Fixed Expose additional type hints used in signatures of public API. [0.5.0] - 2020-01-06 Added exit_on_error added to parse_args() as an optional argument. When False , the function will raise an exception instead of exiting the application if the arguments can't be parsed. Changed Rewrote Columbo example script text. Made example script stand alone. Test against each supported python version in CI. Add support for python 3.8. Use prompt-toolkit for user interaction instead of click . Mark user_io sub-module as private. Expose exception types raised by library. Fixed Add Args class that user_io relies on. Explicit type is required for singledispatch on python 3.6. Specify minimum supported python version. Removed Ability to run the module as an application. Dynamic loading of questions from a file. [0.4.0] - 2019-12-17 Changed return type of Validator return type updated from bool to Optional[str] is_valid function updated to validate , return type updated from bool to Optional[str] Fixed BasicQuestion constructor now respects the validator argument If validator callable provided, question will be asked until validator returns True [0.3.0] - 2019-11-21 get_answers() takes optional answers dict, appending new answers to this as opposed to new dictionary [0.2.0] - 2019-11-08 Added get_answers() takes list of interactions and builds dict of answers, handling user I/O [0.1.0] - 2019-10-15 Initial Release","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"","title":"[Unreleased]"},{"location":"CHANGELOG/#080-2020-02-17","text":"","title":"[0.8.0] - 2020-02-17"},{"location":"CHANGELOG/#added","text":"All Interaction s gained a copy() method to allow for creating slightly altered instances of an existing Interaction . parse_args() and format_cli_help() accept an optional parser_name to be displayed in errors and help text.","title":"Added"},{"location":"CHANGELOG/#changed","text":"Stop producing universal wheels.","title":"Changed"},{"location":"CHANGELOG/#fixed","text":"StaticOrDynamicValue enforces that the result of the callable must be the same type as the static type.","title":"Fixed"},{"location":"CHANGELOG/#removed","text":"DynamicValue is no longer exposed as a type alias.","title":"Removed"},{"location":"CHANGELOG/#070-2020-02-10","text":"","title":"[0.7.0] - 2020-02-10"},{"location":"CHANGELOG/#added_1","text":"format_cli_help() function to produce CLI help text.","title":"Added"},{"location":"CHANGELOG/#changed_1","text":"Type hints on public API. Be more restrictive when functions should not be making mutations. Be less restrictive when functions don't rely on specific implementations.","title":"Changed"},{"location":"CHANGELOG/#fixed_1","text":"CliException inherits from ColumboException . Raise DuplicateQuestionNameException if a list of interactions contains multiple questions with the same name. The same exception is also raised when an existing answers dictionary already contains a name used by a given questions.","title":"Fixed"},{"location":"CHANGELOG/#060-2020-01-13","text":"","title":"[0.6.0] - 2020-01-13"},{"location":"CHANGELOG/#added_2","text":"parse_args() function now accepts an initial dictionary of answers .","title":"Added"},{"location":"CHANGELOG/#fixed_2","text":"Expose additional type hints used in signatures of public API.","title":"Fixed"},{"location":"CHANGELOG/#050-2020-01-06","text":"","title":"[0.5.0] - 2020-01-06"},{"location":"CHANGELOG/#added_3","text":"exit_on_error added to parse_args() as an optional argument. When False , the function will raise an exception instead of exiting the application if the arguments can't be parsed.","title":"Added"},{"location":"CHANGELOG/#changed_2","text":"Rewrote Columbo example script text. Made example script stand alone. Test against each supported python version in CI. Add support for python 3.8. Use prompt-toolkit for user interaction instead of click . Mark user_io sub-module as private. Expose exception types raised by library.","title":"Changed"},{"location":"CHANGELOG/#fixed_3","text":"Add Args class that user_io relies on. Explicit type is required for singledispatch on python 3.6. Specify minimum supported python version.","title":"Fixed"},{"location":"CHANGELOG/#removed_1","text":"Ability to run the module as an application. Dynamic loading of questions from a file.","title":"Removed"},{"location":"CHANGELOG/#040-2019-12-17","text":"","title":"[0.4.0] - 2019-12-17"},{"location":"CHANGELOG/#changed_3","text":"return type of Validator return type updated from bool to Optional[str] is_valid function updated to validate , return type updated from bool to Optional[str]","title":"Changed"},{"location":"CHANGELOG/#fixed_4","text":"BasicQuestion constructor now respects the validator argument If validator callable provided, question will be asked until validator returns True","title":"Fixed"},{"location":"CHANGELOG/#030-2019-11-21","text":"get_answers() takes optional answers dict, appending new answers to this as opposed to new dictionary","title":"[0.3.0] - 2019-11-21"},{"location":"CHANGELOG/#020-2019-11-08","text":"","title":"[0.2.0] - 2019-11-08"},{"location":"CHANGELOG/#added_4","text":"get_answers() takes list of interactions and builds dict of answers, handling user I/O","title":"Added"},{"location":"CHANGELOG/#010-2019-10-15","text":"Initial Release","title":"[0.1.0] - 2019-10-15"},{"location":"api/","text":"Reference TODO","title":"Reference"},{"location":"api/#reference","text":"TODO","title":"Reference"},{"location":"getting-started/","text":"Getting Started Installation To install columbo , simply run this simple command in your terminal of choice: python -m pip install columbo Introduction The core of columbo are the interaction classes. They provide a way to use code to define how information should be displayed to the user and how the user should provide feedback to the running application. The most commonly used Interactions are the Questions. BasicQuestion - Print text to the terminal. Allow the user to type a text response. Pressing Enter submits the response. Choice - Print text to the terminal, followed by a numbered list of options. Allow the user to enter the number of the option they wish to select. Pressing Enter submits the response. Confirm - Print text to the terminal which expects a Yes or No answer. Pressing Y or N submits the corresponding response. In addition to those question types, there are types for when the user needs to be presented with information without providing a response. Echo - Print text to the terminal, but don't stop to accept any input from the user. Acknowledge - Print text to the terminal. Wait for the user to press Enter . After columbo has processed the questions, it returns a dictionary. More specifically the type is Dict[str, Union[str, bool]] ( columbo exposes Answers as an alias for this type). The dictionary maps question names to question answers. If the Question was Confirm , the answer will be bool . Otherwise, the answer will be str . Creating Interactions The constructors for each of these types all take a variety of arguments to configure how they should operate. The following statements cover the basic functionality: Every Interaction has a message argument that is the text that should be displayed to the user. Every Question has a name argument that is the key to be used in the Answers dictionary. Each question must have a unique name. Every Question has a default argument that is used when the user does not provide a specific value. The Usage Guide provides more detailed information about the specifics of each argument for each type of Interaction . Dynamic Values In most cases, an argument to an Interaction constructor can be dynamic (the Usage Guide details the cases where the argument can't be dynamic). A dynamic value is a function that takes the answers that have been provided this far and returns the expected value as a result. For example, message expects a string. So it also accepts a function that accepts Answers and returns a string. import columbo def dynamic_hello ( answers ): return f \"Hello { answers [ 'name' ] } \" interactions = [ columbo . BasicQuestion ( \"name\" , \"What is your name?\" ), columbo . Echo ( dynamic_hello ) ] columbo . get_answers ( interactions ) When iterating through these interactions, if the user replied \"Alice\" to the first question, \"Hello Alice\" would be printed next. Walking Though a Basic Example This is the example that appears on the main page of the documentation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions ) print ( answers ) Line 1: Import the columbo module. Line 3 - 25: Create a list of Interactions to be stored in the variable interactions . Line 4: Create an instance of Echo that will display a basic welcome message. Line 5-7: Create an instance of Acknowledge that will tell the user the program will not continue until Enter is pressed. Line 8-12: Create an instance of BasicQuestion that will ask the user to provide their name. The key user will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of Patrick will be used. Line 13-17: Create an instance of BasicQuestion that will ask the user to provide their email address. The displayed message is dynamic and will include the value from the previous question. The key user_email will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of me@example.com will be used. Line 18-23: Create an instance of Choice that will ask the user for their current mood. The question allows the user to select one of four options. The key mood will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of happy will be used. Line 24: Create an instance of Confirm that will ask the user if they like dogs. The key likes_dogs will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of True will be used. Line 27: Have columbo iterate over the Interactions prompting the user for each question. Line 28: Print tha Answers dictionary so that the values can be seen. Walking Though a Basic Command Line Example This is the example will be just like the previous example , except it will demonstrate the Command Line functionality. The relevant change can be seen here: 24 25 26 27 28 29 30 31 columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-docs\" , ]) print ( answers ) The full example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-docs\" , ]) print ( answers ) Line 27-30: Have columbo iterate over the Interactions parsing the given command line arguments. Line 28: Provide the value of patrick@example.com for the question requesting the user's email address. Line 29: Select the value of True for the question asking the user if they like dogs. Note The arg parameter to get_answers() can be omitted to use the values in sys.argv . What's Next? Read the Usage Guide for a more detailed descriptions of the ways columbo can be used. Read the API Reference for specific information about all the functions and classes made available by columbo .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"To install columbo , simply run this simple command in your terminal of choice: python -m pip install columbo","title":"Installation"},{"location":"getting-started/#introduction","text":"The core of columbo are the interaction classes. They provide a way to use code to define how information should be displayed to the user and how the user should provide feedback to the running application. The most commonly used Interactions are the Questions. BasicQuestion - Print text to the terminal. Allow the user to type a text response. Pressing Enter submits the response. Choice - Print text to the terminal, followed by a numbered list of options. Allow the user to enter the number of the option they wish to select. Pressing Enter submits the response. Confirm - Print text to the terminal which expects a Yes or No answer. Pressing Y or N submits the corresponding response. In addition to those question types, there are types for when the user needs to be presented with information without providing a response. Echo - Print text to the terminal, but don't stop to accept any input from the user. Acknowledge - Print text to the terminal. Wait for the user to press Enter . After columbo has processed the questions, it returns a dictionary. More specifically the type is Dict[str, Union[str, bool]] ( columbo exposes Answers as an alias for this type). The dictionary maps question names to question answers. If the Question was Confirm , the answer will be bool . Otherwise, the answer will be str .","title":"Introduction"},{"location":"getting-started/#creating-interactions","text":"The constructors for each of these types all take a variety of arguments to configure how they should operate. The following statements cover the basic functionality: Every Interaction has a message argument that is the text that should be displayed to the user. Every Question has a name argument that is the key to be used in the Answers dictionary. Each question must have a unique name. Every Question has a default argument that is used when the user does not provide a specific value. The Usage Guide provides more detailed information about the specifics of each argument for each type of Interaction .","title":"Creating Interactions"},{"location":"getting-started/#dynamic-values","text":"In most cases, an argument to an Interaction constructor can be dynamic (the Usage Guide details the cases where the argument can't be dynamic). A dynamic value is a function that takes the answers that have been provided this far and returns the expected value as a result. For example, message expects a string. So it also accepts a function that accepts Answers and returns a string. import columbo def dynamic_hello ( answers ): return f \"Hello { answers [ 'name' ] } \" interactions = [ columbo . BasicQuestion ( \"name\" , \"What is your name?\" ), columbo . Echo ( dynamic_hello ) ] columbo . get_answers ( interactions ) When iterating through these interactions, if the user replied \"Alice\" to the first question, \"Hello Alice\" would be printed next.","title":"Dynamic Values"},{"location":"getting-started/#walking-though-a-basic-example","text":"This is the example that appears on the main page of the documentation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions ) print ( answers ) Line 1: Import the columbo module. Line 3 - 25: Create a list of Interactions to be stored in the variable interactions . Line 4: Create an instance of Echo that will display a basic welcome message. Line 5-7: Create an instance of Acknowledge that will tell the user the program will not continue until Enter is pressed. Line 8-12: Create an instance of BasicQuestion that will ask the user to provide their name. The key user will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of Patrick will be used. Line 13-17: Create an instance of BasicQuestion that will ask the user to provide their email address. The displayed message is dynamic and will include the value from the previous question. The key user_email will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of me@example.com will be used. Line 18-23: Create an instance of Choice that will ask the user for their current mood. The question allows the user to select one of four options. The key mood will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of happy will be used. Line 24: Create an instance of Confirm that will ask the user if they like dogs. The key likes_dogs will be used in the Answers dictionary for the value from this question. If the user presses Enter without providing a value, the default of True will be used. Line 27: Have columbo iterate over the Interactions prompting the user for each question. Line 28: Print tha Answers dictionary so that the values can be seen.","title":"Walking Though a Basic Example"},{"location":"getting-started/#walking-though-a-basic-command-line-example","text":"This is the example will be just like the previous example , except it will demonstrate the Command Line functionality. The relevant change can be seen here: 24 25 26 27 28 29 30 31 columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-docs\" , ]) print ( answers ) The full example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import columbo interactions = [ columbo . Echo ( \"Welcome to the Columbo example\" ), columbo . Acknowledge ( \"Press enter to start\" ), columbo . BasicQuestion ( \"user\" , \"What is your name?\" , default = \"Patrick\" , ), columbo . BasicQuestion ( \"user_email\" , lambda answers : f \"\"\"What email address should be used to contact { answers [ \"user\" ] } ?\"\"\" , default = \"me@example.com\" ), columbo . Choice ( \"mood\" , \"How are you feeling today?\" , options = [ \"happy\" , \"sad\" , \"sleepy\" , \"confused\" ], default = \"happy\" , ), columbo . Confirm ( \"likes_dogs\" , \"Do you like dogs?\" , default = True ), ] answers = columbo . get_answers ( interactions , args = [ \"--user-email\" , \"patrick@example.com\" , \"--likes-docs\" , ]) print ( answers ) Line 27-30: Have columbo iterate over the Interactions parsing the given command line arguments. Line 28: Provide the value of patrick@example.com for the question requesting the user's email address. Line 29: Select the value of True for the question asking the user if they like dogs. Note The arg parameter to get_answers() can be omitted to use the values in sys.argv .","title":"Walking Though a Basic Command Line Example"},{"location":"getting-started/#whats-next","text":"Read the Usage Guide for a more detailed descriptions of the ways columbo can be used. Read the API Reference for specific information about all the functions and classes made available by columbo .","title":"What's Next?"},{"location":"usage-guide/","text":"Usage Guide This is page provides detailed descriptions of al the ways columbo can be used. If you are new to columbo , the Getting Started page provides a gradual introduction of the basic functionality with examples. Static vs Dynamic Values Before diving into the specifics about each Interaction type, it is important to understand how columbo supports both static and dynamic values. A static value is a value that is known when creating an Interaction instance. Frequently this will be a value like a string literal, but that is not a requirement. In contrast, a dynamic value is one which depends on one or more answer provided by the user from a previous question. This is supported by accepting a function that takes an Answers dictionary as an argument and returns a value with the type of that static value would have. For example, the static value for message is str . Therefore, tye dynamic value would be a function that accepts Answers and returns a string ( Callable[[Answers],str] ). In most cases, any argument to an Interaction 's constructor can be dynamic. This guide will explicitly mention when the constructor requires an argument to be a static value. Interactions columbo provides five types of Interactions that can be used to control how the program will interact with the user: Echo - Print text to the terminal, but don't stop to accept any input from the user. Acknowledge - Print text to the terminal. Wait for the user to press Enter . BasicQuestion - Print text to the terminal. Allow the user to type a text response. Pressing Enter submits the response. Choice - Print text to the terminal, followed by a numbered list of options. Allow the user to enter the number of the option they wish to select. Pressing Enter submits the response. Confirm - Print text to the terminal which expects a Yes or No answer. Pressing Y or N submits the corresponding response. Creating Interactions Echo & Acknowledge Echo and Acknowledge both accept message as their only argument. This is the message to be displayed to the user. All Questions BasicQuestion , Choice , & Confirm all accept the following arguments. name : The identifier that will be used as the key to access this question's answer. Each question must have a unique value for name . Can't be dynamic . message : The message to be displayed to the user. default : The default answer to the question. This is used when the user does not provide an explicit value. should_ask : Optional. When given, the argument should be a function that accepts an Answers dictionary and returns True or False . Returning True indicates that the question should be asked. Returning False will skip the question and not present it to the user. See Only Asking Some Questions for more details. cli_help : Optional. A help message to be displayed for command line interface. See CLI documentation for more details. Can't be dynamic . Basic Question In addition to the arguments mentioned above , BasicQuestion also accepts the following argument. validator : Optional. When given, the argument should be a function that accepts a string and an Answers dictionary. The first value is the answer provided by the user. The Answers dictionary will contain the value for each previous question that has been asked. If the value is valid, the function and should return None . If the value is invalid, the function should return a string describing why the value is invalid. This message will be displayed to the user, and the question will be re-asked. Not providing this argument means that any value provided by the user will be accepted. Choice In addition to the arguments mentioned above , Choice also accepts the following argument. options : The list of possible value the user can choose from. Confirm Confirm doesn't take any additional arguments that weren't mentioned above . However, the default argument takes a bool instead of str . Only Asking Some Questions There are situations where a question should be asked some times, but not all the time. For example, a program that collects information about a user's pets should not ask the user for the dog's name and breed if the user said they do not have a dog. The should_ask argument that is present on each question provides a way to achieve this functionality. Similarly, should_ask can be used to provide branching paths to the user. An example of these branching paths is a Choose Your Own Adventure story. The story provides the reader with choices during the adventure. These choices introduce diverging paths of interactions that may or may not join at the end. Warning When columbo skips over a question, the Answers dictionary will NOT contain a key-value pair for the skipped question. The examples below will demonstrate this result. Optional Questions The following is a basic example that has two optional questions that are not asked based on the answer to the first question. import columbo def does_user_have_a_dog ( answers : columbo . Answers ) -> bool : return answers [ \"has_dog\" ] interactions = [ columbo . Confirm ( \"has_dog\" , \"Do you have a dog?\" , default = True ), columbo . BasicQuestion ( \"dog_name\" , \"What is the name of the dog?\" , should_ask = does_user_have_a_dog , default = \"Kaylee\" ), columbo . BasicQuestion ( \"dog_breed\" , \"What is the breed of the dog?\" , should_ask = does_user_have_a_dog , default = \"Basset Hound\" ) ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) If the user accepts the default answers for each of these questions, the output will be: {\"has_dog\": True, \"dog_name\": \"Kaylee\", \"dog_breed\": \"Basset Hound\"} However, when the user answers the first question with \"no\", the output will be: {\"has_dog\": False} Note that in this case, the Answers dictionary only has an answer to the first question. Branching Paths A question that is part of a branching path is very similar to an optional question. It is still a question where the should_ask function was provided to determine if the question should be skipped or not. The branching aspect comes there being at least two sets of optional questions. Each set has a should_ask argument that checks for a different state for a single answer. In this way, only one of the sets of optional questions will ever be asked. The following is an example of a short story that has two divergent paths that join at the end. Each individual question isn't different from the optional questions demonstrated above . The program achieves the branching paths by supplying different should_ask values that will never both evaluate to True . import columbo def went_left ( answers : columbo . Answers ) -> bool : return answers [ \"which_door\" ] == \"left\" def went_right ( answers : columbo . Answers ) -> bool : return answers [ \"which_door\" ] == \"right\" def outcome ( answers : columbo . Answers ) -> str : if answers . get ( \"has_key\" , False ): return \"You try the the key on the lock. With a little jiggling, it finally opens. You open the gate and leave.\" if answers . get ( \"has_hammer\" , False ): return \"You hit the lock with the hammer and it falls to the ground. You open the gate and leave.\" return ( \"Unable to open the gate yourself, you yell for help. A farmer in the nearby field hears you. \" \"He reaches into his pocket and pulls out a key to unlock the gate and open it. \" \"As you walk through the archway he says, \" \" \\\" What I don't understand is how you got in there. This is the only key. \\\" \" ) interactions = [ columbo . Echo ( \"You wake up in a room that you do not recognize. \" \"In the dim light, you can see a large door to the left and a small door to the right.\" ), columbo . Choice ( \"which_door\" , \"Which door do you walk through?\" , options = [ \"left\" , \"right\" ], default = \"left\" ), columbo . Confirm ( \"has_key\" , \"You step into a short hallway and the door closes behind you, refusing to open again. \" \"As you walk down the hallway, there is a small side table with a key on it. \\n \" \"Do you pick up the key before going through the door at the other end?\" , should_ask = went_left , default = True ), columbo . Confirm ( \"has_hammer\" , \"You step into smaller room and the door closes behind, refusing to open again. \" \"The room has a single door on the opposite side of the room and a work bench with a hammer on it. \\n \" \"Do you pick up the hammer before going through the door at the other side?\" , should_ask = went_right , default = True ), columbo . Echo ( \"You enter a small courtyard with high walls. There is an archway that would allow you to go free, \" \"but the gate is locked.\" ), columbo . Echo ( outcome ), ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) For this example, the output display while iterating over the interactions is the interesting part of the program. However, it is important to note that is only possible for the Answers dictionary to have a key-value pair for has_key or has_hammer , not both. Command Line Interface In addition to providing an interactive terminal based UI to ask the user each question, columbo can also generate a command line argument parser based on the list of Interaction s. When used in this manor, Echo & Acknowledge are ignored. To produce a consistent command line argument format, the value of each question's name will be transformed using the following rule: If the there are any upper-case characters, lower-case characters will be used. If the there are is a space character, a dash will be used in its place. If the there are is an underscore character, a dash will be used in its place. For example: Original Result user user user_email user-email User Email user-email Warning As a result of the transformation process, it is possible to have a sequence of question with unique name s for the Answers dictionary, but cause a collision when creating command line arguments. For BasicQuestion & Choice , the result will be preceded with two dashes (ex: --user or --user-email ). For Confirm , columbo produces two command lines arguments. After following the transformation rules, the command line arguments will be --{NAME} & --no-{NAME} to explicitly specify True or False , respectively (ex: --likes-dogs and --no-likes-dogs ) Since the argument parser must be constructed before receiving any user input, all Question s produce arguments. should_ask is only considered when processing the given arguments.","title":"Usage Guide"},{"location":"usage-guide/#usage-guide","text":"This is page provides detailed descriptions of al the ways columbo can be used. If you are new to columbo , the Getting Started page provides a gradual introduction of the basic functionality with examples.","title":"Usage Guide"},{"location":"usage-guide/#static-vs-dynamic-values","text":"Before diving into the specifics about each Interaction type, it is important to understand how columbo supports both static and dynamic values. A static value is a value that is known when creating an Interaction instance. Frequently this will be a value like a string literal, but that is not a requirement. In contrast, a dynamic value is one which depends on one or more answer provided by the user from a previous question. This is supported by accepting a function that takes an Answers dictionary as an argument and returns a value with the type of that static value would have. For example, the static value for message is str . Therefore, tye dynamic value would be a function that accepts Answers and returns a string ( Callable[[Answers],str] ). In most cases, any argument to an Interaction 's constructor can be dynamic. This guide will explicitly mention when the constructor requires an argument to be a static value.","title":"Static vs Dynamic Values"},{"location":"usage-guide/#interactions","text":"columbo provides five types of Interactions that can be used to control how the program will interact with the user: Echo - Print text to the terminal, but don't stop to accept any input from the user. Acknowledge - Print text to the terminal. Wait for the user to press Enter . BasicQuestion - Print text to the terminal. Allow the user to type a text response. Pressing Enter submits the response. Choice - Print text to the terminal, followed by a numbered list of options. Allow the user to enter the number of the option they wish to select. Pressing Enter submits the response. Confirm - Print text to the terminal which expects a Yes or No answer. Pressing Y or N submits the corresponding response.","title":"Interactions"},{"location":"usage-guide/#creating-interactions","text":"","title":"Creating Interactions"},{"location":"usage-guide/#echo-acknowledge","text":"Echo and Acknowledge both accept message as their only argument. This is the message to be displayed to the user.","title":"Echo &amp; Acknowledge"},{"location":"usage-guide/#all-questions","text":"BasicQuestion , Choice , & Confirm all accept the following arguments. name : The identifier that will be used as the key to access this question's answer. Each question must have a unique value for name . Can't be dynamic . message : The message to be displayed to the user. default : The default answer to the question. This is used when the user does not provide an explicit value. should_ask : Optional. When given, the argument should be a function that accepts an Answers dictionary and returns True or False . Returning True indicates that the question should be asked. Returning False will skip the question and not present it to the user. See Only Asking Some Questions for more details. cli_help : Optional. A help message to be displayed for command line interface. See CLI documentation for more details. Can't be dynamic .","title":"All Questions"},{"location":"usage-guide/#basic-question","text":"In addition to the arguments mentioned above , BasicQuestion also accepts the following argument. validator : Optional. When given, the argument should be a function that accepts a string and an Answers dictionary. The first value is the answer provided by the user. The Answers dictionary will contain the value for each previous question that has been asked. If the value is valid, the function and should return None . If the value is invalid, the function should return a string describing why the value is invalid. This message will be displayed to the user, and the question will be re-asked. Not providing this argument means that any value provided by the user will be accepted.","title":"Basic Question"},{"location":"usage-guide/#choice","text":"In addition to the arguments mentioned above , Choice also accepts the following argument. options : The list of possible value the user can choose from.","title":"Choice"},{"location":"usage-guide/#confirm","text":"Confirm doesn't take any additional arguments that weren't mentioned above . However, the default argument takes a bool instead of str .","title":"Confirm"},{"location":"usage-guide/#only-asking-some-questions","text":"There are situations where a question should be asked some times, but not all the time. For example, a program that collects information about a user's pets should not ask the user for the dog's name and breed if the user said they do not have a dog. The should_ask argument that is present on each question provides a way to achieve this functionality. Similarly, should_ask can be used to provide branching paths to the user. An example of these branching paths is a Choose Your Own Adventure story. The story provides the reader with choices during the adventure. These choices introduce diverging paths of interactions that may or may not join at the end. Warning When columbo skips over a question, the Answers dictionary will NOT contain a key-value pair for the skipped question. The examples below will demonstrate this result.","title":"Only Asking Some Questions"},{"location":"usage-guide/#optional-questions","text":"The following is a basic example that has two optional questions that are not asked based on the answer to the first question. import columbo def does_user_have_a_dog ( answers : columbo . Answers ) -> bool : return answers [ \"has_dog\" ] interactions = [ columbo . Confirm ( \"has_dog\" , \"Do you have a dog?\" , default = True ), columbo . BasicQuestion ( \"dog_name\" , \"What is the name of the dog?\" , should_ask = does_user_have_a_dog , default = \"Kaylee\" ), columbo . BasicQuestion ( \"dog_breed\" , \"What is the breed of the dog?\" , should_ask = does_user_have_a_dog , default = \"Basset Hound\" ) ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) If the user accepts the default answers for each of these questions, the output will be: {\"has_dog\": True, \"dog_name\": \"Kaylee\", \"dog_breed\": \"Basset Hound\"} However, when the user answers the first question with \"no\", the output will be: {\"has_dog\": False} Note that in this case, the Answers dictionary only has an answer to the first question.","title":"Optional Questions"},{"location":"usage-guide/#branching-paths","text":"A question that is part of a branching path is very similar to an optional question. It is still a question where the should_ask function was provided to determine if the question should be skipped or not. The branching aspect comes there being at least two sets of optional questions. Each set has a should_ask argument that checks for a different state for a single answer. In this way, only one of the sets of optional questions will ever be asked. The following is an example of a short story that has two divergent paths that join at the end. Each individual question isn't different from the optional questions demonstrated above . The program achieves the branching paths by supplying different should_ask values that will never both evaluate to True . import columbo def went_left ( answers : columbo . Answers ) -> bool : return answers [ \"which_door\" ] == \"left\" def went_right ( answers : columbo . Answers ) -> bool : return answers [ \"which_door\" ] == \"right\" def outcome ( answers : columbo . Answers ) -> str : if answers . get ( \"has_key\" , False ): return \"You try the the key on the lock. With a little jiggling, it finally opens. You open the gate and leave.\" if answers . get ( \"has_hammer\" , False ): return \"You hit the lock with the hammer and it falls to the ground. You open the gate and leave.\" return ( \"Unable to open the gate yourself, you yell for help. A farmer in the nearby field hears you. \" \"He reaches into his pocket and pulls out a key to unlock the gate and open it. \" \"As you walk through the archway he says, \" \" \\\" What I don't understand is how you got in there. This is the only key. \\\" \" ) interactions = [ columbo . Echo ( \"You wake up in a room that you do not recognize. \" \"In the dim light, you can see a large door to the left and a small door to the right.\" ), columbo . Choice ( \"which_door\" , \"Which door do you walk through?\" , options = [ \"left\" , \"right\" ], default = \"left\" ), columbo . Confirm ( \"has_key\" , \"You step into a short hallway and the door closes behind you, refusing to open again. \" \"As you walk down the hallway, there is a small side table with a key on it. \\n \" \"Do you pick up the key before going through the door at the other end?\" , should_ask = went_left , default = True ), columbo . Confirm ( \"has_hammer\" , \"You step into smaller room and the door closes behind, refusing to open again. \" \"The room has a single door on the opposite side of the room and a work bench with a hammer on it. \\n \" \"Do you pick up the hammer before going through the door at the other side?\" , should_ask = went_right , default = True ), columbo . Echo ( \"You enter a small courtyard with high walls. There is an archway that would allow you to go free, \" \"but the gate is locked.\" ), columbo . Echo ( outcome ), ] user_answers = columbo . get_answers ( interactions ) print ( user_answers ) For this example, the output display while iterating over the interactions is the interesting part of the program. However, it is important to note that is only possible for the Answers dictionary to have a key-value pair for has_key or has_hammer , not both.","title":"Branching Paths"},{"location":"usage-guide/#command-line-interface","text":"In addition to providing an interactive terminal based UI to ask the user each question, columbo can also generate a command line argument parser based on the list of Interaction s. When used in this manor, Echo & Acknowledge are ignored. To produce a consistent command line argument format, the value of each question's name will be transformed using the following rule: If the there are any upper-case characters, lower-case characters will be used. If the there are is a space character, a dash will be used in its place. If the there are is an underscore character, a dash will be used in its place. For example: Original Result user user user_email user-email User Email user-email Warning As a result of the transformation process, it is possible to have a sequence of question with unique name s for the Answers dictionary, but cause a collision when creating command line arguments. For BasicQuestion & Choice , the result will be preceded with two dashes (ex: --user or --user-email ). For Confirm , columbo produces two command lines arguments. After following the transformation rules, the command line arguments will be --{NAME} & --no-{NAME} to explicitly specify True or False , respectively (ex: --likes-dogs and --no-likes-dogs ) Since the argument parser must be constructed before receiving any user input, all Question s produce arguments. should_ask is only considered when processing the given arguments.","title":"Command Line Interface"}]}